#lang racket

; 有一对正整数的表，我们要从中造出一对整数，一个表取一个数据，它们的和是素数
; 可以采用如下过程描述
(define (prime-sum-pair list1 list2)
  (let ((a (an-element-of list1))    ; 一个表取一个数字
        (b (an-element-of list2)))   ; 
    (require (prime? (+ a b)))       ; prime?检测是否是素数，而require是只有为真，才执行下边的。
    (list a b)))
; 这里的关键想法是，从an-element-of选择一个元素后，如果后边的require通不过，则重新选，
; 这个好像是暴力破解吧，只是用更抽象的方式来编写。
; 这里跟流比较一下，
; 流利用了惰性求值，只是提供部分数据给下一层，而不是一次性全部给的。
; 而这里的非确定性求值，时间是有分支的，而我们的程序里保存着所有可能的不同执行历史，
; 在遇到一个死胡同时，我们总是可以回到以前的某个选择点，并沿着另一个分支继续下去。

; 为了支持非确定性，这里有一个amb的新特殊形式，
; 表达式(amb e1 e2 e3 ...)  ,有歧义性的返回ei之一的值。
; 而单纯的(amb)，没有参数的，对它的求值将会导致计算失败，不会返回任何值。
; 利用这一思想，可以定义如下的
